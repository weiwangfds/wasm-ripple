<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASM-MQ Benchmark</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .card { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: #f9f9f9; }
        .result { font-family: monospace; font-size: 1.2em; color: #2c3e50; font-weight: bold; }
        button { background: #0070f3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em; }
        button:hover { background: #0051a2; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #logs { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: monospace; height: 300px; overflow-y: auto; white-space: pre-wrap; }
    </style>
</head>
<body>
    <h1>WASM-MQ Performance Benchmark</h1>
    
    <div class="card">
        <h3>Configuration</h3>
        <p>Run benchmark suite to measure throughput, latency, and overhead.</p>
        <button id="runBtn">Run Benchmark</button>
    </div>

    <div id="results"></div>

    <h3>Logs</h3>
    <div id="logs"></div>

    <script type="module">
        // Dynamic import to bust cache
        const { default: init, MessageQueue } = await import('../pkg/wasm_ripple.js?v=' + Date.now());

        const logDiv = document.getElementById('logs');
        const resultsDiv = document.getElementById('results');
        const runBtn = document.getElementById('runBtn');

        function log(msg) {
            console.log(msg);
            logDiv.textContent += msg + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function addResult(name, value) {
            const el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `<div>${name}</div><div class="result">${value}</div>`;
            resultsDiv.appendChild(el);
        }

        async function runBenchmark() {
            runBtn.disabled = true;
            resultsDiv.innerHTML = '';
            logDiv.textContent = '';
            
            try {
                log('Initializing WASM module...');
                await init();
                
                const mq = new MessageQueue();
                const iterations = 1000000;
                
                // Test 1: Register Topic Overhead
                log('Benchmarking Topic Registration...');
                const startReg = performance.now();
                const topicId = mq.register_topic('bench-topic');
                const endReg = performance.now();
                addResult('Topic Registration', `${(endReg - startReg).toFixed(4)} ms`);
                
                // Test 2: Subscribe Overhead
                log('Benchmarking Subscribe...');
                let receivedCount = 0;
                const callback = (payload, tid, ts, mid) => {
                    receivedCount++;
                };
                const startSub = performance.now();
                const subId = mq.subscribe(topicId, callback);
                const endSub = performance.now();
                addResult('Subscription Overhead', `${(endSub - startSub).toFixed(4)} ms`);

                // Define payload early
                const payload = { data: 'test-payload', val: 123 };

                // Test 3b: 100k Sync Publish (Specific Request)
                const items100k = 1000000;
                log(`Benchmarking 100k Sync Publish (${items100k.toLocaleString()} messages)...`);
                
                receivedCount = 0; // Reset
                const start100k = performance.now();
                for (let i = 0; i < items100k; i++) {
                    mq.publish(topicId, payload);
                }
                const end100k = performance.now();
                const duration100k = end100k - start100k;
                const opsPerSec100k = (items100k / duration100k) * 1000;
                
                addResult('100k Sync Throughput', `${opsPerSec100k.toLocaleString(undefined, {maximumFractionDigits: 0})} ops/sec`);
                addResult('100k Total Time', `${duration100k.toFixed(2)} ms`);
                log(`100k Test Received: ${receivedCount}`);

                // Test 3: Publish Throughput (Sync)
                log(`Benchmarking Synchronous Publish (${iterations.toLocaleString()} messages)...`);
                // payload already defined above
                
                const startPub = performance.now();
                for (let i = 0; i < iterations; i++) {
                    mq.publish(topicId, payload);
                }
                const endPub = performance.now();
                const durationPub = endPub - startPub;
                const opsPerSec = (iterations / durationPub) * 1000;
                
                addResult('Sync Publish Throughput', `${opsPerSec.toLocaleString(undefined, {maximumFractionDigits: 0})} ops/sec`);
                addResult('Total Time', `${durationPub.toFixed(2)} ms`);
                log(`Received count: ${receivedCount}`);

                // Test 4: Batch Publish Throughput
                log('Benchmarking Batch Publish (simulated)...');
                // Creating a large array for batch testing
                const batchSize = 1000;
                const batchCount = 1000; // 1M total
                const batchPayloads = new Array(batchSize).fill(payload);
                
                receivedCount = 0; // Reset count
                const startBatch = performance.now();
                for (let i = 0; i < batchCount; i++) {
                    mq.publish_batch_by_id(topicId, batchPayloads);
                }
                const endBatch = performance.now();
                const durationBatch = endBatch - startBatch;
                const batchOpsPerSec = ((batchSize * batchCount) / durationBatch) * 1000;
                
                addResult('Batch Publish Throughput', `${batchOpsPerSec.toLocaleString(undefined, {maximumFractionDigits: 0})} ops/sec`);
                addResult('Batch Time', `${durationBatch.toFixed(2)} ms`);

                // Test 5: End-to-End Latency (Single Message)
                log('Measuring Round-trip Latency...');
                const latencyIterations = 1000;
                let totalLatency = 0;
                
                // Create a separate topic for latency test to avoid interference
                const latencyTopic = mq.register_topic('latency-test');
                
                // We need a way to measure timestamp. 
                // Since callback receives timestamp from Rust (creation time), we can compare with current time.
                // But Rust timestamp is f64 milliseconds.
                
                let latencySum = 0;
                mq.subscribe(latencyTopic, (p, t, ts, mid) => {
                    const now = performance.now();
                    // ts is Date.now() from Rust side, might be slightly different base
                    // Better to measure JS side roundtrip
                    // But here we just want to measure dispatch time
                });

                const startLatency = performance.now();
                for(let i=0; i<latencyIterations; i++) {
                    mq.publish(latencyTopic, payload);
                }
                const endLatency = performance.now();
                const avgLatency = (endLatency - startLatency) / latencyIterations * 1000; // microseconds
                
                addResult('Avg Dispatch Latency', `${avgLatency.toFixed(2)} Âµs/op`);

                mq.close();
                log('Benchmark completed successfully.');
                
            } catch (e) {
                log('Error: ' + e);
                console.error(e);
            } finally {
                runBtn.disabled = false;
            }
        }

        runBtn.addEventListener('click', runBenchmark);
        
        // Auto-run for automation purposes if query param present
        if (new URLSearchParams(window.location.search).has('autorun')) {
            runBenchmark();
        }
    </script>
</body>
</html>
